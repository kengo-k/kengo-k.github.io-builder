---
title: 'プログラミング初心者じゃないけどRustむずくない？所有権についてまとめる！'
date: '2023-06-17'
tags:
  - rust
  - programming
summary: "Rustの所有権について調べました。Rustの中で最も特徴的な要素の一つが「所有権」で、Rustプログラミングのメモリ安全性を保証する重要な概念です。今回の記事では具体例を見ながら所有権の概念を理解できるように解説してみました。Rustの所有権を正しく理解し、コードの品質と効率性を向上させていきましょう！"

thumbnail: rust
featureImage: "./top.jpg"

draft: true
---

Rustの所有権の基本について

まずは次のコードを見てください。
なんの変哲もない、数値を格納したローカル変数aを別のローカル変数bにコピーをするだけのプログラムです。

```rust
fn main() {
    let a = 10;
    let b = a;
    println!("a: {}, b: {}", a, b);
}
```

実行すると次の出力が得られます。

{{<q>}}
a: 10, b: 10
{{</q>}}

あまりにも当たり前すぎるので特に語ることはありません。
ではさらに続けて次のコードをご覧ください。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = a;
    println!("a: {:?}, b: {:?}", a, b);
}
```

一つ前の例ではローカル変数は数値でしたが、今回は文字列になりました。
変更点はそれだけです。しかし、このコードは不正でありビルドエラーになります。
このエラーはRustにおいては通常の挙動であり、所有権のルールにしたがっていないために起こります。

所有権システムを簡単に解説すると以下のようになります。

- Rustでは値(ここではPerson構造体のインスタンス)は変数によって所有される
- 原則として1つの値につき1つの所有者が存在する
- 所有者でない変数から値にアクセスすることはできない
- 変数の値を別の変数に代入すると所有権が移動(これをムーブと呼ぶ)する

変数aを宣言した時点で、変数aは文字列"Hello,World!!"に対する所有権を保持しています。
そしてbに代入した時点で所有権はbに移動し、aは所有権を失うため文字列にアクセスすることはできなくなります。
そのためprintln!でaの値を表示する箇所はルール違反となりビルドエラーになります。

### なぜRustは所有権システムを持つのか

RustはC/C++と同様にGCを持たない言語です。
GCを持たない場合は本来であればプログラマが自分でリソースの解放処理を記述しなければいけないはずです。
しかしRustでは通常そのようなリソース解放処理を書くことはありません。

{{% notice info "MEMO" %}}
「unsafe」な処理を記述する場合は明示的なリソース解放処理を書く必要があります。
{{% /notice %}}

RustにはGCを持たないにも関わらず自動でメモリを解放する仕組みがあり、この仕組みを支えているのが所有権システムです。
Rustのメモリ解放の一番基本的なルールは次のとおりです。

- 変数が指すメモリはその変数がスコープを抜けた時に自動で解放される

ここでC++の簡単な例を見てみます。

```cpp
#include <iostream>

class MyClass {
public:
    ~MyClass() {
      std::cout << "deleted!!" << std::endl;
    }
};

int main() {
    MyClass obj;
    return 0;
}
```

(C++なんて知らんという方もいると思いますが)このコードを実行するとどうなるかわかりますか？
"deleted!!"と表示されるか、もしくはされないかの二択が考えられますね。この場合は表示されます。

これはMyClassをnewしていないためです。newしていないクラスのインスタンスはスタック領域に確保されます。
スタック領域に確保されたメモリは関数の終了時に自動的に解放されます。よって、このコードは明示的な
リソース解放処理をしていないにも関わらずデストラクタが呼ばれ"deleted"が表示されます。

次に先ほどのコードのmain関数を次のように修正してみます。

```cpp
int main() {
  MyClass *obj = new MyClass();
  // ↓の行をコメントアウトすると"deleted"は表示されない
  delete obj;
  return 0;
}
```

今度はMyClassをnewするように修正しました。
newによりオブジェクトを作成した場合、インスタンスはヒープ領域に確保されます。
ヒープ領域の場合はメモリは自動で解放されないため手動で解放(delete)する必要があります。

上記コードのコメントにも書いている通りdeleteを実行する行をコメントアウトすると
"deleted"が表示されなくなることが確認できます。これを踏まえてRustのコードに戻ります。

C++の最初の例をRustに直すと次のようになります。

```rust

```




const a = [1,2,3];
const b = a;
a.push(4);
console.log(a); // [1,2,3,4]
console.log(b); // [1,2,3,4]



RustにはGCがないので別の仕組みでメモリを解放する必要があります。
そのGCではないメモリ解放の仕組みが所有権システムです。

Rustではある値の所有権をただ一つの変数が持ち、その変数がスコープから外れた時にメモリを解放します。
所有権を失った変数にアクセスすることはできません。そのようなコードを書いた場合はビルドに失敗します。

なぜ所有権を持てる変数は一つだけなのか、は複数の変数が同時に所有権を持つ場合、
それらの変数がスコープから外れた時にメモリの多重解放が起きてしまうためです。
(C言語で同じメモリアドレスを2回freeしてしまうのと同じです)

最初のi32をコピーする例において、なぜビルドエラーが起きないのでしょうか？
それはプリミティブ型は所有権の移動が起こらないからです。
プリミティブ型の場合はムーブではなくコピーが起こります。
つまり同じ値を持つメモリ領域が複製される挙動となります。

Rustではデフォルトでプリミティブ型はコピーでそれ以外はムーブとなります。
ただし、明示的にCopyであると宣言することができます。

先ほどのstructをコピーする例を以下のようにします。

```rust

```

Stringはヒープに確保される。ヒープに確保されたデータは通常の所有権のシステムとは違う方法で管理されるのか？
