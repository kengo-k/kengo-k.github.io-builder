---
title: 'プログラミング歴そこそこ長いけどRust難しいよ・・・所有権について理解したい！！'
date: '2023-06-17'
tags:
  - rust
  - programming
summary: "Rustの所有権について調べました。Rustの中で最も特徴的な要素の一つが「所有権」で、Rustプログラミングのメモリ安全性を保証する重要な概念です。今回の記事では具体例を見ながら所有権の概念を理解できるように解説してみました。Rustの所有権を正しく理解し、コードの品質と効率性を向上させていきましょう！"

thumbnail: rust
featureImage: "./top.jpg"

draft: true
---

## Rustの所有権を親切丁寧に解説することを試みる

Rustの所有権システムの基本的な考え方、使い方についてサンプルコードを書いてみたり、AIと問答したりしながら自分なりに理解するためのステップをまとめてみました。自分自身の理解を深めることが第一の目標ですが、誰にでも理解できるように書いているつもりです。

ただし他の言語の経験があることを前提に書いています。また所有権の説明のみに注力しているため本記事に出てくるRustコードのそれ以外の要素についての解説はほとんど省いているためご了承ください。必要があると感じた部分については都度、説明を入れていきます。

ではさっそく始めましょう。まずは次のコードを見てください。

```rust
fn main() {
    let a = 10;
    let b = a;
    println!("a: {}, b: {}", a, b);
}
```

数値を格納したローカル変数aを別のローカル変数bにコピーをしています。何の変哲もないシンプルなプログラムです。このコードを実行すると次の出力が得られます。

{{<q>}}
a: 10, b: 10
{{</q>}}

この結果は誰もが予想できたと思います。当たり前すぎるため特に語ることはありません。では続けて次のコードを見てください。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = a;
    println!("a: {:?}, b: {:?}", a, b);
}
```

一つ前の例では数値で初期化していたローカル変数が今回は文字列になりました。変更点はそれだけです。しかし、このコードは不正であり、ビルドエラーになります。このエラーはRustにおいてはデフォルトの挙動であり、所有権のルールにしたがっていないために起こっています。

数値型の例がビルドエラーにならないのは、数値型がコピーのセマンティクスを持つ特別な型だからです。「コピーのセマンティクスを持つ」とは、変数を代入したときに代入元と同じ値を持つ新しいメモリ領域が複製つまりコピーされることを意味します。

{{% notice info "MEMO" %}}


コピーではない場合は「ムーブ」となります。コピーが発生するのは数値型の他に、論理型(bool値)、文字型など、いくつかの基本的な型のみであり、Rustではムーブがデフォルトです。そのため上記のコードがエラーになるのはデフォルトの挙動であると表現しました。

ムーブのセマンティクスについては後ほど解説します。
{{% /notice %}}

{{% notice tip "TIP" %}}
上述したようにユーザ定義の型もデフォルトでムーブですが、Copyトレイトを実装することでコピーに変更することができます。
{{% /notice %}}

所有権システムの基本ルールは以下のとおりです：

- 値は変数によって所有され、原則として1つの値につき1つの所有者が存在する
- 所有者でない変数はその値にアクセスすることはできない
- 変数を別の変数に代入すると所有権が移動(これをムーブと呼ぶ)する

{{% notice tip "TIP" %}}
「原則として」と表記しているとおり例外はあります。`Rc<T>`のようなスマートポインタを使う場合、複数の所有者が存在します。
{{% /notice %}}

変数aを宣言した時点で、変数aは文字列"Hello,World!!"に対する所有権を保持しています。そしてbに代入した時点で所有権はbに移動し、aは所有権を失います。そのためprintln!でaの値を表示する箇所がルール違反となりビルドエラーになります。

実際にエラーメッセージを見てみましょう。

{{< i prefix="1-" method="resize" width=1920 >}}

4行目で変数aに対するアクセスがエラーとなっていることが確認できます。

### なぜRustは所有権システムを持つのか

RustはC/C++と同様にGCを持たない言語です。GCを持たない言語では本来ならばプログラマが自分でリソースの解放処理を書かなければいけないはずです。しかしRustでリソース解放処理を書くことは基本的にありません。さらに言えば明示的にリソースを解放する手段が提供されていないので、そもそもリソース解放処理を書くことはできません。

{{% notice tip "TIPS" %}}
例外として「unsafe」な処理を記述する場合は明示的なリソース解放処理を書く必要があります。
{{% /notice %}}

GCを持たないにも関わらずRustには自動でメモリを解放する仕組みがあり、この仕組みを支えているのが所有権システムです。Rustにおけるメモリ解放のルールは次のとおりです：

- 変数が指すメモリはその変数がスコープを抜けた時に自動で解放される

このルールについて理解するためにRustと他の言語を比較をしながら考えてみます。ここでは例としてC++の簡単なコードを見てみます。

```cpp
#include <iostream>

class MyClass {
public:
    ~MyClass() {
      std::cout << "deleted!!" << std::endl;
    }
};

int main() {
    MyClass obj;
    return 0;
}
```

(C++なんて知らんという方もいると思いますが)このコードを実行するとどうなるかわかりますか？私もC++のことはほとんど知らないので雰囲気レベルでOKです。

~MyClass() {...}の部分はデストラクタの定義です。デストラクタはメモリが解放されるタイミングで呼び出されます。つまりメモリが解放された場合は"deleted!!"と表示される訳です。よって、このコードを実行すると何が起きるのかを予想する場合、"deleted!!"と表示されるか、もしくはされないかの二択しかなさそうですよね。そして、この場合は表示されます。

これはMyClass型の変数をnewせずに宣言しているからです。newしていないクラスのインスタンスはスタック領域に確保されます。そしてスタック領域に確保されたメモリは関数の終了時に自動的に解放されます。よって、このコードは明示的なリソース解放処理をしていないにも関わらずデストラクタが呼ばれ"deleted"が表示されます。

次に上記コードのmain関数を次のように修正してみます。

```cpp
int main() {
  MyClass *obj = new MyClass();
  delete obj; // この行をコメントアウトするとメモリは解放されない
  return 0;
}
```

今度はMyClassをnewするように修正しました。newによりオブジェクトを作成した場合、インスタンスはヒープ領域に確保されます。
変数objの値自体は変わらずスタック領域に格納されていますが、その値はインスタンスではなく、ヒープ領域を指し示すポインタ(メモリアドレス)となりました。

ヒープ領域に確保したメモリは自動で解放されないため手動で解放(delete)する必要があります。コード内のコメントにも書いているとおりdeleteを実行する行をコメントアウトすると
メモリは解放されません。つまりデストラクタは呼び出されないため"deleted!!"も表示されなくなります。

これを踏まえてRustのコードに戻ります。C++の最初の例をRustに直すと次のようになります。

```rust
struct MyClass {}

impl Drop for MyClass {
    fn drop(&mut self) {
        println!("deleted!!");
    }
}

fn main() {
    let _obj = MyClass{};
}
```

{{% notice tip "TIPS" %}}
未使用変数の警告を抑制するために変数名の頭に_を付与しています。
{{% /notice %}}

RustにはC++のようなクラスやデストラクタが存在しないので代わりにDropトレイトを実装します。Dropトレイトを実装するとメモリ解放の直前に処理を実行できます。つまりこのコードはC++の最初の例と実質的に同じコードになります。MyClassのインスタンスはスタック領域に配置され、実行すると"deleted!!"と表示されます。このコードでメモリが自動で解放されているのはC++と同じ振る舞いでありRust特有のものではありません。

ではC++の二番目の例(newしている例)をRustで書いてみます。main関数のみ掲載します。

```rust
fn main() {
    let _obj = Box::new(MyClass{});
}
```

スマートポインタ`Box<T>`を使うと値をヒープ上に確保します。つまりC++の二番目の例と同じコードになります。このRustコードはC++の例とは違い、明示的にリソース解放処理を記述していないにも関わらず"deleted!!"と表示されます。これはRust特有の挙動であり、すでに書いたメモリ解放のルール：

- 変数が指すメモリはその変数がスコープを抜けた時に自動で解放される

によるものです。このルールに従うと_obj変数がスコープを抜けスタックから削除されるタイミングで_obj変数が指し示すヒープ上のメモリも自動的に解放されます。

ここで疑問ですが、なぜC++は同じような仕組みを提供してくれないのでしょう？自動でメモリを解放してくれる方が便利なはずですよね。その答えは「所有権システムが無いC++には不可能」だからです。C++では実現できない理由について考えてみましょう。C++がRustと同じようにスコープを抜けた時点で自動でヒープ上のメモリを解放してくれる仕様だったと仮定し、以下のコードを見てみます。

```cpp
int main() {
  MyClass *obj1 = new MyClass();
  MyClass *obj2 = obj1;
  return 0;
}
```

変数がスコープを抜けた時点でメモリを解放する場合、obj1とobj2がそれぞれスコープを抜けることで、解放処理が2回実行されてしまいます。Rustではこの挙動は起こりません。その理由を説明するためには、以前書いたメモリ解放のルールをもう少し詳しく書き直す必要があります。正しくは、

- 変数が指すメモリはその`所有権を持つ`変数がスコープを抜けた時に自動で解放される

と書くのが適切です。所有権については冒頭でも書きましたが、そこでは

- 1つの値につき1つの所有者が存在する
- 変数の値を別の変数に代入すると所有権が移動する

と書きました。C++には所有権がないため、obj1とobj2を区別することができません。しかしRustでは所有権を持っている唯一の変数が存在するため、その変数が参照するメモリのみを解放することで二重解放を避けることができます。

```rust
fn main() {
    let _obj1 = Box::new(MyClass{});
    let _obj2 = _obj1
}
```

_obj1を_obj2に代入した時点で_obj1は所有権を失っています。よって最後に所有権を持つ変数は_obj2のみとなります。つまり(絶対に1つだけ存在することが保証されている)所有権を持つ変数だけがスコープを抜けた時に自動で解放されることで、解放処理が2回実行されることは起こらなくなっているのです。

### 借用を使い複数の変数から値にアクセスする

所有権を持つ変数だけがその値にアクセスできることを解説しました。しかし「そんな厳しい制限の中で本当にプログラムが書けるのか」という疑問が湧いてきます。しかしご安心ください、Rustには借用というシステムがあり所有権を持たずに値にアクセスすることが可能です。ここからは借用についての解説を詳しく見ていきます。

#### 借用の使い方

以前書いたエラーになるコードを再掲します。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = a;
    println!("a: {}, b: {}", a, b);
}
```

このコードを修正してビルドエラーが発生しないようにするには次のように修正します。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    println!("a: {}, b: {}", a, b);
}
```

ローカル変数bへ代入する値が`&a`に変わりました。変数名の前に&がついただけです。これは借用を意味し所有権を持たずに値にアクセスすることを可能にします。この記号を他のプログラミング言語で見た覚えのある方がいるかもしれません。例えばC/C++、Goなどにこの記号が登場します。

これらの言語における&記号は参照、つまり変数のアドレスを取得するものでした。実はRustにおいても&記号は同様に参照を意味します。つまりRustでは参照を通して借用の仕組みを提供していると言えます。上記コードではローカル変数bの型はStringの参照であり、bの型は&Stringになります。

#### デリファレンス

参照変数が参照先の値にアクセスするには*記号を使用し逆参照(デリファレンス)を行います。ローカル変数bを通して文字列操作のメソッドを呼び出す例を見てみます。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    let c = (*b).to_uppercase();
    println!("a: {}, b: {}, c: {}", a, *b, c);
}
```

このコードを実行すると以下の出力が得られます。

{{<q>}}
a: Hello,World!!, b: Hello,World!!, c: HELLO,WORLD!!
{{</q>}}

ここでは変数aとcはString型、変数bは&String型となります。bは参照型であるのでデリファレンスして実体を取得してからメソッドを呼び出しています。同様にprintln!に渡す際も変数bはデリファレンスを行なっています。このコードは完全に正当なもので、本来は一番正確な記述をしていると言えるのですが、実はより簡単に以下のように書くことができます。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    let c = b.to_uppercase();
    println!("a: {}, b: {}, c: {}", a, b, c);
}
```

見てのとおり、単にデリファレンス記号が無くなっただけです。このように明示的にデリファレンスする記述がなくても正常にビルド実行できてしまうわけですが、これはデリファレンスが不要なわけではなく、暗黙のデリファレンスが行われていると考えるのが正しいです。

ここでは以下の二箇所で暗黙のデリファレンスが行われています。

1. 参照変数を通したメソッド呼び出しの部分
1. 二つ目はprintln!に参照変数を渡している部分

1.については参照にto_uppercaseメソッドの定義が存在しないため、メソッド定義は実体側にあるだろうとコンパイラが判断して自動でデリファレンスをしてくれるという仕様があるためです。

2.についても同じ仕組みで動作します。println!がフォーマット文字列{}に対し、引数で指定された値を表示するには、値が実装するDisplayトレイトのfmtメソッドを呼び出す必要があります。参照にfmtメソッドが存在しない場合は1.と同様に自動でデリファレンスが起こり、実体に定義されたfmtが呼び出されます。

{{% notice tip "TIP" %}}
この自動でデリファレンスする仕様についてはRustの公式ドキュメントでは「型強制」という機能として説明されています。
{{% /notice %}}

### 値の変更と参照変数との関係

ここまでのコードでは値を変更する処理はありませんでした。ここからは値の変更に関するRust特有のルールについて見ていきます。特に参照変数が存在している状況で値の変更を行う場合に色々と複雑なルールを理解する必要があります。ここでは、それらのルールについての解説を行なっていきます。

まずは参照が関わらない単純な例を見ていきます。以下のコード：

```rust
fn main() {
    let a = String::from("Hello");
    a.push_str(",World!!");
    println!("a: {}", a);
}
```

このコードはビルドエラーになります。Stringのメソッドpush_strを呼び出すコードですが、push_strはその名前のとおり引数で指定した文字列を追加するメソッドです。このメソッドは内部に持つ文字列の状態を変更します。Rustでは変数はデフォルトで不変となるため、内部状態を変更するpush_strを呼ぶ出すことはできないためビルドエラーとなります。

このエラーを回避するためには、以下のようにコードを修正します：

```rust
fn main() {
    let mut a = String::from("Hello");
    a.push_str(",World!!");
    println!("a: {}", a);
}
```

変数宣言のletの後にmutがついています。mutはmutationの意味で可変の変数を宣言するために使用します。このコードはビルドに成功し実行すると以下の出力が得られます。

{{<q>}}
a: Hello,World!!
{{</q>}}

次に参照を通して変更を行う例を見ていきます。通常の変数と同じように参照もデフォルトで不変です。可変の参照を得るには下記のように&mutを使います：

```rust
fn main() {
    let mut a = String::from("Hello");
    let b = &mut a;
    b.push_str(",World!!");
    println!("a: {}", a);
}
```

&mutを使用してaの可変参照をbに設定しています。コードを見てわかるとおり、可変参照を通して変更を行うには参照先自体も可変でなければなりません。つまり変数a自体もmutが指定されている必要があります(当たり前ですが)。

このコードでは可変参照bを通して文字列",World!!"を追記をしています。その結果、変数aの値として"Hello,World!!"が表示されます。このコード自体はとても自然な挙動であると言えます。

そして、ここから少しややこしくなってきます。変数bはaを参照しています。つまりaと同じ値を見ているはずですね。それを確認するために以下のようにコードを修正します。

```rust
fn main() {
    let mut a = String::from("Hello");
    let b = &mut a;
    b.push_str(",World!!");
    println!("a: {}", a);
    println!("b: {}", b); // これを追加しただけ
}
```

最終行にbの値を出力するprintln!を追加しただけです。何も問題がないように見えます。しかし、このコードはビルドエラーになります。

{{< i prefix="2-" method="resize" width=1920 >}}

以降でなぜこのエラーが発生するのかについて詳細を解説していきます。

### 詳解：データ変更とデータ競合防止について

Rustではデータ変更の際に、意図しないバグを防ぐためのルールがあります。このルールはデータ競合を防ぐために存在し、上述したエラーの理由もルールを読み解けば理解できます。ルールは以下のとおりです。

- 不変参照が存在している間、所有者はデータの変更をしてはならない
- 可変参照は同時に他の参照と存在することはできない
- 可変参照が存在する間、可変参照以外はデータにアクセスしてはならない

{{% notice info "「参照が存在する」とは" %}}
上記ルール中で「参照が存在する」という言い回しをしています。シンプルに読むと「参照が存在する」とは参照変数が生きている間、つまり関数やブロックのスコープ内は参照が存在しているという理解をしたくなります。しかし、ここで言う「参照が存在する」とは「参照が作られた時から最後に使われた時まで」を指します。つまり参照が存在する範囲は関数やブロックのスコープよりも短くなる可能性があります。
{{% /notice %}}

これから上記ルールについてコードを交えて詳しく見ていきます。

#### 不変参照が存在している間、所有者はデータの変更をしてはならない

このルールは割とイメージしやすいかと思います。不変参照が存在するのにデータの変更を許すと、(不変だったはずなのに)知らぬ間に値が変わっている可能性があります。これは意図しないバグを誘発する可能性があり禁止となっています。

```rust
fn main() {
    let mut x = 10;
    let px = &x;
    x = 20;
    println!("px: {}", px);
}
```

このコードはビルドエラーです。最終行のprintln!でpxを使用しているため、最終行の時点まで不変参照pxが生存します。よって「不変参照が存在している間、所有者はデータの変更をしてはならない」のルールに違反します。println!をコメントアウトするとエラーは消えます。

#### 可変参照は同時に他の参照と存在することはできない

このルールを噛み砕くと、

- 可変参照は一つだけ存在でき、同時に他の参照(可変/不変問わず)が存在してはならない
- 不変参照は同時に複数存在してもよい

と解釈できます。次のコードは可変参照が同時に二つ存在するためルール違反です。

```rust
fn main() {
    let mut x = 10;
    let px1 = &mut x;
    let px2 = &mut x;
    println!("px1: {}", px1);
}
```

{{< i prefix="3-" method="resize" width=1920 >}}

二個目の可変参照が作成されたというエラーメッセージが表示されています。

今度はpx2を不変に修正します。

```rust
fn main() {
    let mut x = 10;
    let px1 = &mut x;
    let px2 = &x;
    println!("px1: {}", px1);
}
```

{{< i prefix="4-" method="resize" width=1920 >}}



可変参照が存在している間は、他の全ての参照は存在できないため、このコードもやはりエラーです。

px1も不変に修正して可変参照が存在しないようにします。

```rust
fn main() {
    let mut x = 10;
    let px1 = &x;
    let px2 = &x;
    println!("px1: {}", px1);
}
```

このコードはルールに違反しないため正常に動作します。

#### 可変参照が存在する間、可変参照以外はデータにアクセスしてはならない

一つ前のルールで可変参照が存在する間、他の参照は存在しないことを確認しました。よってデータにアクセスする可能性があるのは

- 所有者
- 可変参照

の二つだけです。つまり、このルールは可変参照が存在する間は所有者といえどもデータへのアクセス(読み書き)ができないことを意味します。

```rust
fn main() {
    let mut x = 10;
    let px = &mut x;
    let y = x;
    println!("px: {}", px);
}
```

最終行まで可変参照pxが生存しています。よって所有者であるxの値は書き込みも読み込みも禁止されます。よってローカル変数yにxを代入するコードはルール違反となりエラーです。

すべてのルールを見てきました。今なら最初のコードがなぜエラーになったのかわかります。エラーになったコードを再掲します。

```rust
fn main() {
    let mut a = String::from("Hello");
    let b = &mut a;
    b.push_str(",World!!");
    println!("a: {}", a);
    println!("b: {}", b); // これを追加しただけ
}
```

可変参照であるbは、letで宣言された時点から最終行のprintln!まで存在します。その間は所有者はデータにアクセスできません。println!でaを出力する行は所有者からデータへのアクセスを試みているのでルール違反となります。

### Rustにおける文字列型：Stringと&strについて

少し話題が変わりますが、ここでRustにおける文字列について話します。このタイミングで文字列を扱うのは、次に解説するライフタイムのサンプルコードで&str型を使用するため、その前にStringと&strの違いなどについて、説明が必要になるためです。

これまでのサンプルコードでは文字列を扱う際、String型のみを使いました。Rustプログラミングでは文字列を扱う際は主にStringと&strを使用します。

#### String型について

Stringは可変文字列の型です。可変なので内部状態を変更できます。以前のサンプルコードではpush_strを使い文字列を状態を変更しました。Stringは実際の文字列データ自体は保持しません。Stringが保持するのは以下の情報です。

- 文字列の実体データへのポインタ
- 文字列の長さ(len)
- 文字列が確保しているメモリ領域の容量(capacity)

Stringが持つポインタが指し示す先の、文字列の実体データがstr型です。

#### &str型について

String型についての解説内で書いたとおり、str型とは文字列の実体データの型です。よって&str型はstrの参照を表す型、となります。

Rustで文字列を扱う際は主にStringと&strを使うと書きました。strではなく&strを使うのは、strの型が事前に確定しないためです。サイズが不明な型を変数として直接使うことはできないため代わりに&strを通して扱います。



#### 文字列リテラルの型

ではソースコード内に直接ハードコードされる文字列リテラルの型は何になるでしょうか？すでに文字列の実体はstrであると書きました。そしてstrは直接利用できないため参照を通して使うことも書きました。よって文字列リテラルは&strの型を持ちます。

Stringが指し示す文字列データはヒープ領域に配置されることはすでに説明しました。では文字列リテラルはどこに配置されるのでしょうか？答えはスタックでもヒープでもない、静的メモリ領域(static領域)に配置されます。static領域はプログラムの開始から終了まで存在するグローバルなメモリ領域となります。

文字列リテラルの型が&strなのは間違いないのですが、この型は省略形となっており、正確に書くと&'static str型と書くのが正しいです。&'static str型の変数はつまり永続する文字列データであることを意味します。

以下のコードを見てみます。

```rust
fn main() {
    let s: &str;
    {
        let message: String = String::from("Hello,World!!");
        s = message.as_str();
    }
    println!("s: {}", s);
}
```

このコードはビルドエラーになります。messageが指し示すヒープ上の文字列データはmain関数内の内部ブロックが終了した時点で解放されてしまいます。よって変数sは、内部ブロックを抜けた後は無効な参照になってしまうためです。このコードを次のように修正します。

```rust
fn main() {
    let s: &str;
    {
        let message: &'static str = "Hello, World!!";
        s = message;
    }
    println!("s: {}", s);
}
```

このコードは正常に実行できます。変数messageが指す文字列データはstatic領域に配置されるので内部ブロックを抜けてもメモリ解放されることはありません。そのため変数sも内部ブロックを抜けても無効な参照になることがないためです。変数sの型は&strであるにも関わらず、&'static str型の変数messageを代入できるのはコンパイラがsの正しい型を推論するためです。

&'static strの「'static」の部分をライフタイム指定子と呼びます。名前のとおり参照が生存する範囲を指定するものです。'staticは予約語であり、グローバルな寿命をもつ特別なライフタイムとなります。以降でライフタイムについて詳しくみていきます。

### ライフタイム指定を理解する

ライフタイム指定は参照が生きている範囲を指定するものです。
