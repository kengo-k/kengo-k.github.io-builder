---
title: 'プログラミング歴そこそこ長いけどRust難しいよ・・・所有権について理解したい！！'
date: '2023-06-17'
tags:
  - rust
  - programming
summary: "Rustの所有権について調べました。Rustの中で最も特徴的な要素の一つが「所有権」で、Rustプログラミングのメモリ安全性を保証する重要な概念です。今回の記事では具体例を見ながら所有権の概念を理解できるように解説してみました。Rustの所有権を正しく理解し、コードの品質と効率性を向上させていきましょう！"

thumbnail: rust
featureImage: "./top.jpg"

draft: true
---

## Rustの所有権を親切丁寧に解説することを試みる

Rustの所有権システムの基本的な考え方、使い方について色々調べたり、サンプルコード書いたり、AIと問答しながら自分なりに理解するためのステップをまとめてみました。自分自身の理解を深めることが第一の目標ですが、一応誰にでも理解できるように書いているつもりです。

ただし他の言語の経験があることを前提に書いています。また所有権の説明のみに注力しているため本記事に出てくるRustコードのその他の要素についての解説はほとんどありませんのでご了承ください。

まずは次のコードを見てください。なんの変哲もない、数値を格納したローカル変数aを別のローカル変数bにコピーをするだけのプログラムです。

```rust
fn main() {
    let a = 10;
    let b = a;
    println!("a: {}, b: {}", a, b);
}
```

実行すると次の出力が得られます。

{{<q>}}
a: 10, b: 10
{{</q>}}

この結果は当たり前すぎるので特に語ることはありません。では続けて次のコードをご覧ください。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = a;
    println!("a: {:?}, b: {:?}", a, b);
}
```

一つ前の例では数値で初期化していたローカル変数が今回は文字列になりました。
変更点はそれだけです。しかし、このコードは不正でありビルドエラーになります。
このエラーはRustにおいては通常の挙動であり、所有権のルールにしたがっていないために起こっています。

{{% notice info "MEMO" %}}
数値型の例でビルドエラーにならないのは、数値型がコピーのセマンティクスを持つ特別な型だからです。
「コピーのセマンティクスを持つ」とは、変数を代入したときに代入元と同じ値を持つ新しいメモリ領域が複製されることを意味します。

コピーではない場合はムーブとなりますが、コピーが起こるのは数値型の他に、論理型(bool値)、文字型など、いくつかの基本的な型のみとなります。
つまりRustでのデフォルトの挙動はムーブであり、上記のコードではエラーになるのが通常の挙動であると言えます。

ムーブのセマンティクスについては、この後で解説しています。
{{% /notice %}}

{{% notice tip "TIP" %}}
ユーザ定義の型も上述したようにデフォルトでムーブとなりますが、Copyトレイトを実装することでコピーに変更することができます(詳細は割愛します)。
{{% /notice %}}

所有権システムを簡単に解説すると以下のようになります。

- Rustでは値は変数によって所有される
- 原則として1つの値につき1つの所有者が存在する
- 所有者でない変数はその変数が持つ値にアクセスすることはできない
- 変数を別の変数に代入すると所有権が移動(これをムーブと呼ぶ)する

変数aを宣言した時点で、変数aは文字列"Hello,World!!"に対する所有権を保持しています。
そしてbに代入した時点で所有権はbに移動し、aは所有権を失うため文字列にアクセスすることはできなくなります。
そのためprintln!でaの値を表示する箇所がルール違反となりビルドエラーになります。

### なぜRustは所有権システムを持つのか

RustはC/C++と同様にGCを持たない言語です。
GCを持たない言語では本来プログラマが自分でリソースの解放処理を記述しなければいけないはずです。
しかしRustでは通常そのようなリソース解放処理を書くことはありません。
※さらに言えば明示的にリソースを解放する方法が無いのでそもそも書くことができません。

{{% notice tip "TIPS" %}}
「unsafe」な処理を記述する場合は明示的なリソース解放処理を書く必要があります。
{{% /notice %}}

GCを持たないにも関わらずRustには自動でメモリを解放する仕組みがあり、この仕組みを支えているのが所有権システムです。
Rustのメモリ解放の基本的なルールは次のとおりです。

- 変数が指すメモリはその変数がスコープを抜けた時に自動で解放される

ここでC++の簡単な例を見てみます。

```cpp
#include <iostream>

class MyClass {
public:
    ~MyClass() {
      std::cout << "deleted!!" << std::endl;
    }
};

int main() {
    MyClass obj;
    return 0;
}
```

(C++なんて知らんという方もいると思いますが)このコードを実行するとどうなるかわかりますか？

`~MyClass(){...}`の部分はデストラクタの定義です。デストラクタはメモリが解放されるタイミングで呼び出されます。
つまりメモリが解放された場合は"deleted!!"と表示される訳です。よって、このコードを実行した場合に、"deleted!!"と表示されるか、もしくはされないかの二択が考えられますね。この場合は表示されます。

これはMyClass型の変数をnewせずに宣言しているからです。newしていないクラスのインスタンスはスタック領域に確保されます。
スタック領域に確保されたメモリは関数の終了時に自動的に解放されます。
よって、このコードは明示的なリソース解放処理をしていないにも関わらずデストラクタが呼ばれ"deleted"が表示されます。

次に上記コードのmain関数を次のように修正してみます。

```cpp
int main() {
  MyClass *obj = new MyClass();
  // ↓の行をコメントアウトすると"deleted"は表示されない
  delete obj;
  return 0;
}
```

今度はMyClassをnewするように修正しました。
newによりオブジェクトを作成した場合、インスタンスはヒープ領域に確保されます。
そして変数objは値そのものではなく、ヒープ領域を指し示すポインタとなりました。

ヒープ領域に確保したメモリは自動で解放されないため手動で解放(delete)する必要があります。
コード内のコメントにも書いている通りdeleteを実行する行をコメントアウトすると
"deleted!!"が表示されなくなります。

これを踏まえてRustのコードに戻ります。C++の最初の例をRustに直すと次のようになります。

```rust
struct MyClass {}

impl Drop for MyClass {
    fn drop(&mut self) {
        println!("deleted!!");
    }
}

fn main() {
    let _obj = MyClass{};
}
```

{{% notice tip "TIPS" %}}
未使用変数の警告を抑制するために変数名の頭に_を付与しています
{{% /notice %}}

RustにはC++のようなクラスやデストラクタが存在しないので代わりにDropトレイトを実装します。
Dropトレイトを実装するとメモリ解放の直前に処理を実行できます。つまりこのコードはC++の最初の例とほぼ同じコードです。
MyClassのインスタンスはスタック領域に配置され、実行すると"deleted!!"と表示されます。

ではC++の二番目の例(newしている例)をRustで書いてみます。main関数のみ掲載します。

```rust
fn main() {
    let _obj = Box::new(MyClass{});
}
```

スマートポインタ`Box<T>`を使うと値をヒープ上に確保します。つまり二番目の例と同じコードになります。
しかしC++とは違い明示的にリソース解放をせずとも、"deleted!!"と表示されます。
これはすでに書いたルール：

- 変数が指すメモリはその変数がスコープを抜けた時に自動で解放される

によるものです。_objはヒープ上のメモリアドレスを指していて、_obj変数がスコープを抜けスタックから削除されるタイミングでヒープ上のメモリも自動的に解放されます。

なぜC++は同じような仕組みを提供できないのでしょうか？自動でメモリを解放してくれる方が簡単で便利なはずです。
その答えは「所有権システムが無いので不可能」だからです
(そもそもC++が目指す方向性と違うということもあります。C++はメモリ管理に関してプログラマにより大きな自由度を与えています)。

ここでC++がRustと同じようにスコープを抜けた時点で自動でメモリを解放してくれる仕様であると仮定し、次のようなコードを考えてみます。

```cpp
int main() {
  MyClass *obj1 = new MyClass();
  MyClass *obj2 = obj1;
  return 0;
}
```

変数がスコープを抜けた時点でメモリを解放する場合、obj1とobj2がそれぞれスコープを抜けることで、解放処理が2回実行されてしまいます。
Rustではこの挙動は起こらないようになっています。その理由を説明するためには、先ほど書いたルールをもう少し詳しく書き直す必要があります。

- 変数が指すメモリはその`所有権を持つ`変数がスコープを抜けた時に自動で解放される

がより正しい説明となります。所有権については冒頭でも書きましたが、その中に、

- 原則として1つの値につき1つの所有者が存在する
- 変数の値を別の変数に代入すると所有権が移動(これをムーブと呼ぶ)する

というものがありました。C++ではobj1とobj2を区別するための方法がありません。しかしRustで同じコードを考えてみると、

```rust
fn main() {
    let _obj1 = MyClass{};
    let _obj2 = _obj1
}
```

_obj1を_obj2に代入した時点で_obj1は所有権を失っています。よって最後に所有権を持つ変数は_obj2のみとなります。つまり(絶対に1つだけ存在することが保証されている)所有権を持つ変数だけがスコープを抜けた時に自動で解放されることで、解放処理が2回実行されることは起こらなくなっているのです。

### 所有権と借用について

所有権を持つ変数だけがその値にアクセスできることを解説しました。しかし「そんな厳しい制限の中で本当にプログラム書けるのか」という疑問が湧いてきます。しかしご安心ください(？)、Rustには借用というシステムがあり、所有権を持たずとも値にアクセスすることを可能にします。ここからは借用についての解説を行なっていきます。

#### 借用の使い方

以前書いたエラーになるコードを再掲します。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = a;
    println!("a: {:?}, b: {:?}", a, b);
}
```

このコードを修正してビルドエラーが発生しないようにするには次のように修正します。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    println!("a: {:?}, b: {:?}", a, b);
}
```

bへ代入する箇所が`&a`に変わりました。変数名の前に&がついたということです。この&記号は借用を意味し、所有権を持たずして変数の値にアクセスすることを可能とします。この&記号ですが、他のプログラミング言語で見覚えのある方がいるかもしれません。例えばC/C++、Goなどで&記号が登場します。

これらの言語における&は参照、つまり変数のアドレスを取得するものです。Rustにおける&記号も同じく参照を意味します。つまりRustでは参照を通して借用の仕組みを提供します。ローカル変数bの型はStringの参照であり、&Stringとなります。

#### デリファレンス

参照変数が参照先の値にアクセスするには*記号を使用し逆参照(デリファレンス)を行います。ローカル変数bを通して文字列操作のメソッドを呼び出す例を見てみます。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    let c = (*b).to_uppercase();
    println!("a: {}, b: {}, c: {}", a, b, c);
}
```

このコードを実行すると以下の出力が得られます。

{{<q>}}
a: Hello,World!!, b: Hello,World!!, c: HELLO,WORLD!!
{{</q>}}

参照変数であるbをデリファレンスして実体を取得しメソッドを呼び出しています。このコードは完全に正当なもので、本来は一番正確な記述をしていると言えるのですが、実はさらに簡単に書くことができます：

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    let c = b.to_uppercase();
    println!("a: {}, b: {}, c: {}", a, b, c);
}
```

このようにデリファレンスの記述がなくても正常にビルド実行できます。これはデリファレンスを明示していないだけで、暗黙のデリファレンスが行われています。この挙動は参照変数がメソッド呼び出しをしているのだから、当然デリファレンスされるべきとコンパイラが推測して自動的にデリファレンスをしてくれている、と考えることができます。

#### 状態を変更する

変数が持つ値を変更する例を見ていきます。以下のビルドエラーになるコードを見てみます。

```rust
fn main() {
    let a = String::from("Hello");
    a.push_str(",World!!");
    println!("a: {}", a);
}
```

Stringのメソッドpush_strを呼び出すコードです。push_strはその名前のとおり引数で指定した文字列を追加するメソッドです。このメソッドは内部の文字列の状態を変更します。Rustでは変数はデフォルトで不変となります。つまり変数aが指す値は不変であるため、内部状態を変更するメソッドpush_strを呼ぶ出すことはできないためビルドエラーとなります。

このエラーを回避するためには、以下のようにコードを修正します：

```rust
fn main() {
    let mut a = String::from("Hello");
    a.push_str(",World!!");
    println!("a: {}", a);
}
```

変数宣言のletの後にmutがついています。mutはmutationの意味で可変変数を宣言するために使用します。続いて参照を通した変更を見ていきます。通常の変数と同じように、参照もデフォルトで不変となっています。可変の参照を得るには&mutを使います：

```rust

```



&を使用して取得した参照は不変の参照となります。つまり参照を通して値を変更することはできません。

### 所有権システムが高度なメモリ安全性を提供する

ここまでの内容でRustが所有権システムを使いGCがなくとも自動的にメモリを解放する仕組みを解説しました。
しかし所有権システムの利点はそれだけではありません。所有権システムがあることで、他の言語では発生しうるメモリ起因のバグがRustでは発生しません。

具体例を見ていきます。今度はJavascriptの例を取り上げます。

```js
const a = [1,2,3];
const b = a;
a.push(4);
console.log(a); // [1,2,3,4]
console.log(b); // [1,2,3,4]
```

この例では、変数aとbは同じメモリを指しているため、変数aを通して行われた変更は変数bにも波及します。
この挙動はJavascriptを日常的に使っているプログラマにとってはごく自然なものかと思います。

しかし、このようなコードは一般的にはバグを生みやすい操作として避けるべきものとされています。
もちろん意図的にこのようなコードを書くこともありうるため、一概に悪いとは言えないのですが。
