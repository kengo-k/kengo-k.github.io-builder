---
title: 'プログラミング歴そこそこ長いけどRust難しいよ・・・所有権について理解したい！！'
date: '2023-06-17'
tags:
  - rust
  - programming
summary: "Rustの所有権について調べました。Rustの中で最も特徴的な要素の一つが「所有権」で、Rustプログラミングのメモリ安全性を保証する重要な概念です。今回の記事では具体例を見ながら所有権の概念を理解できるように解説してみました。Rustの所有権を正しく理解し、コードの品質と効率性を向上させていきましょう！"

thumbnail: rust
featureImage: "./top.jpg"

draft: true
---

## Rustの所有権を親切丁寧に解説することを試みる

Rustの所有権システムの基本的な考え方、使い方についてサンプルコードを書いてみたり、AIと問答したりしながら自分なりに理解するためのステップをまとめてみました。自分自身の理解を深めることが第一の目標ですが、誰にでも理解できるように書いているつもりです。

ただし他の言語の経験があることを前提に書いています。また所有権の説明のみに注力しているため本記事に出てくるRustコードのそれ以外の要素についての解説はほとんど省いているためご了承ください。必要があると感じた部分については都度、説明を入れていきます。

ではさっそく始めましょう。まずは次のコードを見てください。

```rust
fn main() {
    let a = 10;
    let b = a;
    println!("a: {}, b: {}", a, b);
}
```

数値を格納したローカル変数aを別のローカル変数bにコピーをしています。何の変哲もないシンプルなプログラムです。このコードを実行すると次の出力が得られます。

{{<q>}}
a: 10, b: 10
{{</q>}}

この結果は誰もが予想できたと思います。当たり前すぎるため特に語ることはありません。では続けて次のコードを見てください。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = a;
    println!("a: {:?}, b: {:?}", a, b);
}
```

一つ前の例では数値で初期化していたローカル変数が今回は文字列になりました。変更点はそれだけです。しかし、このコードは不正であり、ビルドエラーになります。このエラーはRustにおいてはデフォルトの挙動であり、所有権のルールにしたがっていないために起こっています。

数値型の例がビルドエラーにならないのは、数値型がコピーのセマンティクスを持つ特別な型だからです。「コピーのセマンティクスを持つ」とは、変数を代入したときに代入元と同じ値を持つ新しいメモリ領域が複製つまりコピーされることを意味します。

{{% notice info "MEMO" %}}


コピーではない場合は「ムーブ」となります。コピーが発生するのは数値型の他に、論理型(bool値)、文字型など、いくつかの基本的な型のみであり、Rustではムーブがデフォルトです。そのため上記のコードがエラーになるのはデフォルトの挙動であると表現しました。

ムーブのセマンティクスについては後ほど解説します。
{{% /notice %}}

{{% notice tip "TIP" %}}
上述したようにユーザ定義の型もデフォルトでムーブですが、Copyトレイトを実装することでコピーに変更することができます。
{{% /notice %}}

所有権システムの基本ルールは以下のとおりです：

- 値は変数によって所有され、原則として1つの値につき1つの所有者が存在する
- 所有者でない変数はその値にアクセスすることはできない
- 変数を別の変数に代入すると所有権が移動(これをムーブと呼ぶ)する

{{% notice tip "TIP" %}}
「原則として」と表記しているとおり例外はあります。`Rc<T>`のようなスマートポインタを使う場合、複数の所有者が存在します。
{{% /notice %}}

変数aを宣言した時点で、変数aは文字列"Hello,World!!"に対する所有権を保持しています。そしてbに代入した時点で所有権はbに移動し、aは所有権を失います。そのためprintln!でaの値を表示する箇所がルール違反となりビルドエラーになります。

実際にエラーメッセージを見てみましょう。

{{< i prefix="1-" method="resize" width=1920 >}}

4行目で変数aに対するアクセスがエラーとなっていることが確認できます。

### なぜRustは所有権システムを持つのか

RustはC/C++と同様にGCを持たない言語です。GCを持たない言語では本来ならばプログラマが自分でリソースの解放処理を書かなければいけないはずです。しかしRustでリソース解放処理を書くことは基本的にありません。さらに言えば明示的にリソースを解放する手段が提供されていないので、そもそもリソース解放処理を書くことはできません。

{{% notice tip "TIPS" %}}
例外として「unsafe」な処理を記述する場合は明示的なリソース解放処理を書く必要があります。
{{% /notice %}}

GCを持たないにも関わらずRustには自動でメモリを解放する仕組みがあり、この仕組みを支えているのが所有権システムです。Rustにおけるメモリ解放のルールは次のとおりです：

- 変数が指すメモリはその変数がスコープを抜けた時に自動で解放される

このルールについて理解するためにRustと他の言語を比較をしながら考えてみます。ここでは例としてC++の簡単なコードを見てみます。

```cpp
#include <iostream>

class MyClass {
public:
    ~MyClass() {
      std::cout << "deleted!!" << std::endl;
    }
};

int main() {
    MyClass obj;
    return 0;
}
```

(C++なんて知らんという方もいると思いますが)このコードを実行するとどうなるかわかりますか？私もC++のことはほとんど知らないので雰囲気レベルでOKです。

~MyClass() {...}の部分はデストラクタの定義です。デストラクタはメモリが解放されるタイミングで呼び出されます。つまりメモリが解放された場合は"deleted!!"と表示される訳です。よって、このコードを実行すると何が起きるのかを予想する場合、"deleted!!"と表示されるか、もしくはされないかの二択しかなさそうですよね。そして、この場合は表示されます。

これはMyClass型の変数をnewせずに宣言しているからです。newしていないクラスのインスタンスはスタック領域に確保されます。そしてスタック領域に確保されたメモリは関数の終了時に自動的に解放されます。よって、このコードは明示的なリソース解放処理をしていないにも関わらずデストラクタが呼ばれ"deleted"が表示されます。

次に上記コードのmain関数を次のように修正してみます。

```cpp
int main() {
  MyClass *obj = new MyClass();
  delete obj; // この行をコメントアウトするとメモリは解放されない
  return 0;
}
```

今度はMyClassをnewするように修正しました。newによりオブジェクトを作成した場合、インスタンスはヒープ領域に確保されます。
変数objの値自体は変わらずスタック領域に格納されていますが、その値はインスタンスではなく、ヒープ領域を指し示すポインタ(メモリアドレス)となりました。

ヒープ領域に確保したメモリは自動で解放されないため手動で解放(delete)する必要があります。コード内のコメントにも書いているとおりdeleteを実行する行をコメントアウトすると
メモリは解放されません。つまりデストラクタは呼び出されないため"deleted!!"も表示されなくなります。

これを踏まえてRustのコードに戻ります。C++の最初の例をRustに直すと次のようになります。

```rust
struct MyClass {}

impl Drop for MyClass {
    fn drop(&mut self) {
        println!("deleted!!");
    }
}

fn main() {
    let _obj = MyClass{};
}
```

{{% notice tip "TIPS" %}}
未使用変数の警告を抑制するために変数名の頭に_を付与しています。
{{% /notice %}}

RustにはC++のようなクラスやデストラクタが存在しないので代わりにDropトレイトを実装します。Dropトレイトを実装するとメモリ解放の直前に処理を実行できます。つまりこのコードはC++の最初の例と実質的に同じコードになります。MyClassのインスタンスはスタック領域に配置され、実行すると"deleted!!"と表示されます。このコードでメモリが自動で解放されているのはC++と同じ振る舞いでありRust特有のものではありません。

ではC++の二番目の例(newしている例)をRustで書いてみます。main関数のみ掲載します。

```rust
fn main() {
    let _obj = Box::new(MyClass{});
}
```

スマートポインタ`Box<T>`を使うと値をヒープ上に確保します。つまりC++の二番目の例と同じコードになります。このRustコードはC++の例とは違い、明示的にリソース解放処理を記述していないにも関わらず"deleted!!"と表示されます。これはRust特有の挙動であり、すでに書いたメモリ解放のルール：

- 変数が指すメモリはその変数がスコープを抜けた時に自動で解放される

によるものです。このルールに従うと_obj変数がスコープを抜けスタックから削除されるタイミングで_obj変数が指し示すヒープ上のメモリも自動的に解放されます。

ここで疑問ですが、なぜC++は同じような仕組みを提供してくれないのでしょう？自動でメモリを解放してくれる方が便利なはずですよね。その答えは「所有権システムが無いC++には不可能」だからです。C++では実現できない理由について考えてみましょう。C++がRustと同じようにスコープを抜けた時点で自動でヒープ上のメモリを解放してくれる仕様だったと仮定し、以下のコードを見てみます。

```cpp
int main() {
  MyClass *obj1 = new MyClass();
  MyClass *obj2 = obj1;
  return 0;
}
```

変数がスコープを抜けた時点でメモリを解放する場合、obj1とobj2がそれぞれスコープを抜けることで、解放処理が2回実行されてしまいます。Rustではこの挙動は起こりません。その理由を説明するためには、以前書いたメモリ解放のルールをもう少し詳しく書き直す必要があります。正しくは、

- 変数が指すメモリはその`所有権を持つ`変数がスコープを抜けた時に自動で解放される

と書くのが適切です。所有権については冒頭でも書きましたが、そこでは

- 1つの値につき1つの所有者が存在する
- 変数の値を別の変数に代入すると所有権が移動する

と書きました。C++には所有権がないため、obj1とobj2を区別することができません。しかしRustでは所有権を持っている唯一の変数が存在するため、その変数が参照するメモリのみを解放することで二重解放を避けることができます。

```rust
fn main() {
    let _obj1 = Box::new(MyClass{});
    let _obj2 = _obj1
}
```

_obj1を_obj2に代入した時点で_obj1は所有権を失っています。よって最後に所有権を持つ変数は_obj2のみとなります。つまり(絶対に1つだけ存在することが保証されている)所有権を持つ変数だけがスコープを抜けた時に自動で解放されることで、解放処理が2回実行されることは起こらなくなっているのです。

### 借用を使い複数の変数から値にアクセスする

所有権を持つ変数だけがその値にアクセスできることを解説しました。しかし「そんな厳しい制限の中で本当にプログラムが書けるのか」という疑問が湧いてきます。しかしご安心ください、Rustには借用というシステムがあり所有権を持たずに値にアクセスすることが可能です。ここからは借用についての解説を詳しく見ていきます。

#### 借用の使い方

以前書いたエラーになるコードを再掲します。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = a;
    println!("a: {}, b: {}", a, b);
}
```

このコードを修正してビルドエラーが発生しないようにするには次のように修正します。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    println!("a: {}, b: {}", a, b);
}
```

ローカル変数bへ代入する値が`&a`に変わりました。変数名の前に&がついただけです。これは借用を意味し所有権を持たずに値にアクセスすることを可能にします。この記号を他のプログラミング言語で見た覚えのある方がいるかもしれません。例えばC/C++、Goなどにこの記号が登場します。

これらの言語における&記号は参照、つまり変数のアドレスを取得するものでした。実はRustにおいても&記号は同様に参照を意味します。つまりRustでは参照を通して借用の仕組みを提供していると言えます。上記コードではローカル変数bの型はStringの参照であり、bの型は&Stringになります。

#### デリファレンス

参照変数が参照先の値にアクセスするには*記号を使用し逆参照(デリファレンス)を行います。ローカル変数bを通して文字列操作のメソッドを呼び出す例を見てみます。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    let c = (*b).to_uppercase();
    println!("a: {}, b: {}, c: {}", a, *b, c);
}
```

このコードを実行すると以下の出力が得られます。

{{<q>}}
a: Hello,World!!, b: Hello,World!!, c: HELLO,WORLD!!
{{</q>}}

ここでは変数aとcはString型、変数bは&String型となります。bは参照型であるのでデリファレンスして実体を取得してからメソッドを呼び出しています。同様にprintln!に渡す際も変数bはデリファレンスを行なっています。このコードは完全に正当なもので、本来は一番正確な記述をしていると言えるのですが、実はより簡単に以下のように書くことができます。

```rust
fn main() {
    let a = String::from("Hello,World!!");
    let b = &a;
    let c = b.to_uppercase();
    println!("a: {}, b: {}, c: {}", a, b, c);
}
```

見てのとおり、単にデリファレンス記号が無くなっただけです。このように明示的にデリファレンスする記述がなくても正常にビルド実行できてしまうわけですが、これはデリファレンスが不要なわけではなく、暗黙のデリファレンスが行われていると考えるのが正しいです。

ここでは以下の二箇所で暗黙のデリファレンスが行われています。

1. 参照変数を通したメソッド呼び出しの部分
1. 二つ目はprintln!に参照変数を渡している部分

1.については参照にto_uppercaseメソッドの定義が存在しないため、メソッド定義は実体側にあるだろうとコンパイラが判断して自動でデリファレンスをしてくれるという仕様があるためです。

2.についても同じ仕組みで動作します。println!がフォーマット文字列{}に対し、引数で指定された値を表示するには、値が実装するDisplayトレイトのfmtメソッドを呼び出す必要があります。参照にfmtメソッドが存在しない場合は1.と同様に自動でデリファレンスが起こり、実体に定義されたfmtが呼び出されます。

{{% notice tip "TIP" %}}
この自動でデリファレンスする仕様についてはRustの公式ドキュメントでは「型強制」という機能として説明されています。
{{% /notice %}}

### 値の変更と参照変数との関係

ここまでのコードでは値を変更する処理はありませんでした。ここからは値の変更に関するRust特有のルールについて見ていきます。特に参照変数が存在している状況で値の変更を行う場合に色々と複雑なルールを理解する必要があります。ここでは、それらのルールについての解説を行なっていきます。

まずは参照が関わらない単純な例を見ていきます。以下のコード：

```rust
fn main() {
    let a = String::from("Hello");
    a.push_str(",World!!");
    println!("a: {}", a);
}
```

このコードはビルドエラーになります。Stringのメソッドpush_strを呼び出すコードですが、push_strはその名前のとおり引数で指定した文字列を追加するメソッドです。このメソッドは内部に持つ文字列の状態を変更します。Rustでは変数はデフォルトで不変となるため、内部状態を変更するpush_strを呼ぶ出すことはできないためビルドエラーとなります。

このエラーを回避するためには、以下のようにコードを修正します：

```rust
fn main() {
    let mut a = String::from("Hello");
    a.push_str(",World!!");
    println!("a: {}", a);
}
```

変数宣言のletの後にmutがついています。mutはmutationの意味で可変の変数を宣言するために使用します。このコードはビルドに成功し実行すると以下の出力が得られます。

{{<q>}}
a: Hello,World!!
{{</q>}}

次に参照を通して変更を行う例を見ていきます。通常の変数と同じように参照もデフォルトで不変です。可変の参照を得るには下記のように&mutを使います：

```rust
fn main() {
    let mut a = String::from("Hello");
    let b = &mut a;
    b.push_str(",World!!");
    println!("a: {}", a);
}
```

&mutを使用してaの可変参照をbに設定しています。ここで注意ですが可変参照を通して変更を行うには、参照先自体も可変でなければなりません。つまり変数a自体もmutが指定されている必要があります(当たり前ですが)。

このコードでは可変参照bを通して文字列",World!!"を追記をしています。その結果、変数aの値として"Hello,World!!"が表示されます。このコード自体はとても自然な挙動をしているように見えます。

そして、ここから少しややこしくなってきます。変数bはaを参照しています。つまりaと同じ値を持っているはずですね。それを確認してみようと以下のようにコードを修正します。

```rust
fn main() {
    let mut a = String::from("Hello");
    let b = &mut a;
    b.push_str(",World!!");
    println!("a: {}", a);
    println!("b: {}", b);
}
```

最終行にbの値を出力するprintln!を追加しただけです。何も問題がないように見えます。しかし、このコードはビルドエラーになります。

{{< i prefix="2-" method="resize" width=1920 >}}

以降でなぜこのエラーが発生するのかについて詳細を解説していきます。

### 詳解：値の変更と参照についてのルール

上述したエラーが発生する理由について、Rustにおける値の変更と参照についてのルールについて詳しく解説しながら解き明かしていきます。しかし、その前にルール内で使われる用語について事前に認識を合わせておきたいと思います。

これから書くルールの中で「参照が存在する」という言い回しをしています。シンプルに読むと、参照が存在する、とは参照変数が生きている間、つまり関数のスコープにいる間は参照が存在しているという理解をしたくなると思います。しかし、ここで言う「参照が存在する」とは、「参照が初めて作られて、最後に使われた時まで」を指します。つまり参照が存在する範囲は、関数のスコープよりも狭くなりうることを意味します。

以上の前提をもって、ルールについて解説していきます。

#### ルール1.参照が存在している場合、参照元のデータを変更してはならない

参照は「別のデータを見ている」ことを意味します。つまりデータは誰かに見られているわけです。誰かに見られている最中(=参照が存在する)にデータを変更するな、というルールになります。

実際に試してみます。

```rust
fn main() {
    println!("10 * 2 = {}", double(10));
}

/// 引数を2倍にして返す関数
fn double(x: i32) -> i32 {
    let mut a = x;
    let _ref_a = &a;
    a = a * 2;
    a
}
```

このコードは問題なく動作し"10 * 2 = 20"と表示されます。参照_ref_aが宣言されていますが、エラーにはなりません。これは最初に書いた前提を見るとわかります。参照は最後に使われた時まで生存しています。しかし_ref_aは宣言してから一度も使われていません。つまり

#### 2.可変参照は同時に二つ以上存在してはならない

#### 3.可変参照と不変参照は同時に存在してはならない

### 所有権システムが高度なメモリ安全性を提供する

ここまでの内容でRustが所有権システムを使いGCがなくとも自動的にメモリを解放する仕組みを解説しました。
しかし所有権システムの利点はそれだけではありません。所有権システムがあることで、他の言語では発生しうるメモリ起因のバグがRustでは発生しません。

具体例を見ていきます。今度はJavascriptの例を取り上げます。

```js
const a = [1,2,3];
const b = a;
a.push(4);
console.log(a); // [1,2,3,4]
console.log(b); // [1,2,3,4]
```

この例では、変数aとbは同じメモリを指しているため、変数aを通して行われた変更は変数bにも波及します。
この挙動はJavascriptを日常的に使っているプログラマにとってはごく自然なものかと思います。

しかし、このようなコードは一般的にはバグを生みやすい操作として避けるべきものとされています。
もちろん意図的にこのようなコードを書くこともありうるため、一概に悪いとは言えないのですが。


ユーザーがアプリケーションを実装する際に、structにメソッドを定義すると思いますが、通常はstruct自身にメソッドを定義しますよね？あえて参照自体にメソッドを定義することはあり得ますか
